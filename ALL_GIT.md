# GIT & GITHUB


#### 버전관리란

1. 내가 원하는 시점(버전) 으로 이동할 수 있게 해주는 것이 버전 관리이며, 이를 도와주는 툴이 버전관리 시스템 이다.
2. Git 은 소스코드 버전 사이를 오고 가는 시간 여행 이상의 기능을 제공한다.
3. Git Hub 에 소스코드를 올리면 시간, 공간 제약 없이 협업이 가능하다. 
4. 또 전 세계 개발자들과 협업이 가능하다.
5. 이러한 공개 저장소 프로젝트를 오픈소스라고 부른다.


#### Git Bash 창

1. $ 기호는 명령어 입력을 기다리는 커서이다.
2. 리눅스에서는 기본 터미널에서 깃 cli(명령어) 를 수행할 수 있다.


#### Git Init

1. git init 은 초기화 명령어이다.
2. [.git] 이라는 폴더가 자동으로 생성된다.
3. 이 곳에는 버전들의 정보와 원격 저장소의 주소가 들어 있다.
4. [.git] 폴더를 우리는 로컬저장소라고 불른다. 혹은 로컬 깃
5. git 에서 버전을 커밋이라고도 불린다.

다음은 초반에 필요한 전역(사용자) 설정이다.
<img src="../GIT Images/git_01.png" align="left" width="80%" height="60%" ></img>

#### 원격 저장소

1. 깃에서는 원격 저장소를 git hub or git repository 라고 부른다.
2. 로컬 깃에서 원격 저장소를 연결하는 명령어는 다음과 같다 (origin은 별칭이다.)

<img src="../GIT Images/git_02.png" align="left" width="80%" height="60%" ></img>

3. 원격저장소의 버전과 커밋 그리고 코드 전체를 내 컴퓨터에 내려 받는 것을 clone 라고 한다.
4. 다음과 같이 마침표를 찍는 것은 현재 폴더에 소스를 받으라는 것이고, 마침표가 없다면 디렉터리를 제공한다.

<img src="../GIT Images/git_03.png" align="left" width="80%" height="60%" ></img>

5. GitHub 는 단순히 소소를 올리고, 팀원들과 협업하는 것 이상으로 SNS 처럼 사용 가능하다.
6. 마음에 드는 저장소에 STAR 표시하고 요즘 떠오르는 저장소를 Explore 탭에서 훏어볼 수 있다.
7. 서비스를 만든 엔지니어를 팔로우(Fllow)를 해서 어떤 다른 개발 활동을하는 지 보는 것도 흥미롭다.


#### Git Hub 메인 화면

(완쪽 상단)
1. 대시보드 컨텍스트 : 원격저장소를 개인 계정에만 속하게 할 수 있지만, 회사나 단체 이름으로 단체 계정을 만들어 관리 할 수도 있다. 이 대시보드 컨텍스트 전환 버튼을 이용해 메인화면에 어떤 계정을 기준으로 표시할지 선택한다.

2. 저장소 목록(Repositories) : 현재 기여하고 있는 모든 원격저장소 목록이 표시되며, 최근 코드를 올린 순대로 정렬된다. 오른쪽의 new 버튼으로 새 원격저장소를 만들 수 있다.

3. 팀 목록(Your teams) : 단체 계정 안에 더 작은 분류인 team 을 만들 수 있다. 내가 속한 팀 목록이 보인다.

(위 측)
4. 풀 리퀘스트(Pull requests) : 관련된 모든 풀 리퀘스트를 볼 수 있다. 풀 리퀘스트는 코드 협업을 도와주는 기능이다.

5. 이슈(Issues) : 각 저장소에서 해결해야 하는 일들을 이슈로 만들어 둘 수 있다. 나와 관련된 모든 이슈를 볼 수 있다.

6. 마켓플레이스(Marketplace) : 코드를 GitHub에 올리면 자동으로 빌드해 주거나, 메신저와 연동할 수 있는 등의 플러그인을 구입할 수 있다.

7. 둘러보기(Explore) : GitHub 와 관련된 블로그나 요즘 뜨는 저장소 등을 볼 수 있다.

(우측 상단)
8. 알림(Notifications)

9. 새로 만들기 : 저장소나 단체, 혹은 gist(저장소보다 작은 코드를 올리고 싶을 때 유용하다)을 만들 수 있다.

(중앙)
10. 최근 활동(Recent activity) : 내가 팔로우하는 저장소의 최근 활동이 보인다.

11. 모든 활동(All activity) : 내가 팔로우하는 저장소, 나를 팔로워 하는 저장소의 활동이 보인다.

(우측 하단)
12. 뜨는 저장소 둘러보기(Explore repositories) : GitHub 에서 최근 뜨는 원격저장소들이 보여진다. 요즘 오픈소스 트렌드를 확인 할 수 있다.


#### 레포지터리 생성하기 Create a new repository

<strong> Add .gitignore : .gitignore 파일을 추가한다. </strong>
1. 작업을 할 때 굳이 GitHub에 올릴 필요가 없는 파일이 있다. 예를 들어 텍스트 에디터에서 자동으로 생성된 설정파일이나, 보안 비밀번호여서 오픈소스로 올리면 큰일 나는 파일들이다.
2. GitHub에 올리지 않기를 바라는 파일이 자동으로 목록에 추가된다. 추후에도 언제든 수정가능하다.

<strong> Add a licence : 라이선스 파일 추가 </strong>

1. 공개적으로 사용하고, 다른 사용자도 참여하도록 만든 오픈소스에도 지적 재산권을 부여 할 수 있다.
2. Apache 2.0, GPLv3 등이 그것이며 이들은 저작권 명시를 반드시 해야한다는 특징이 있다.
3. 원작자에게 맥주를 사달라는 위트있는 Beerware 라는 라이센스도 있다.
4. 이외에도 https://choosealicense.com/ 에서 프로젝트에 맞는 라이선스를 고를 수 있다.
5. 추후에 변경 가능하다.


#### Git 으로 관리하는 파일의 4가지 상태

1. git은 시점의 파일을 통째로 저장하는 snapshot 이다.
2. 바뀌지 않은 파일은 이전 파일의 링크만 저장하기 때문에 용량도 적고 계산도 하지 않는다. 따라서 빠르다.

3. untracked(추적안됨) : 한 번도 커밋되지 않은 파일일 때
4. staged(스테이지됨) : add 명령어를 통해 stage에 올렸을 때
5. unmodified(수정 없음) : commit 명령어를 통해 하나의 스냅샷, 즉 버전을 만들었을 때
6. modified(수정 됨) : 커밋 된 파일을 수정 했을 때


#### 원격 저장소에서 협업하기 : 브랜치(Branch)

1. 동시에 버전 관리 할때에도 서로의 작업물에 의존하지 않고 내가 원할 때 코드를 올리고, 또 내가 원할 때 협업자의 코드와 합칠 수 있다.
2. git은 병렬 버전 관리가 가능하다.
3. 커밋은 바로 전 커밋을 참조하는 방식이다.
4. 특정 기준에서 줄기를 나누어 작업 할 수 있는 기능을 브랜치(Branch)라고 한다.
5. master, main 이 git에서 제공하는 기본 브랜치이다.
6. 브랜치는 물리적인 길을 의미하는 것이 아니라 단순한 포인터(pointer) 이다.
7. HEAD 라는 특수한 포인터는 브랜치 혹은 커밋을 가리키는 포인터이다. 
8. HEAD 를 이용해서 브랜치 사이를 마음대로 넘나들 수 있다. 
9. master 브랜치를 큰 줄기로 잡고 잔가지에서 조금씩 수정해서 다시 큰 줄기에 합치는 것이다.


#### 브랜치와 브랜치를 합치기 : 병합(merge, 머지)

1. 병합(merge)는 간단히 말해서 두 버전의 합집합을 구하는 것이다.
2. 베이스 브랜치가 병합 커밋을 올리는 브랜치이다.


#### 충돌(conflict) 해결하기

1. 병합 충돌을 해결하고 병합 커밋을 만들면 된다.


#### 브랜치를 합치는 예의바른 방법 : 풀 리퀘스트

1. 병합 전에 협력자의 동의 혹은 확인을 구하는 과정이다.
2. 풀 리퀘스트, 즉 정중하게 병합을 요청할 수 있는 메시지를 적을 수 있는 페이지가 나온다.
3. 여기서 먼저 설정해야 할 건 base 브랜치와 compare 브랜치이다.
4. 커밋이 잘 들어가 있는지 다시 한번 검토한 후에 create pull request 버튼을 클릭한다.
5. 풀 리퀘스트 화면에서 Reviewers 는 협력자를 의미한다. 여러 명이라면 몇 명을 콕 찝어서 이 풀 리퀘스트를 검토해 달라 요청 할 수 있다.
6. Assignees : 풀 리퀘스트를 담당하는 동료를 적는다. 보통 자기자신이다.
7. Labels : 풀 리퀘스트에 대한 라벨이다 예를 들어 [버그], [리뷰 필요], [프런트 엔드], [백 엔드] 등이다.


#### 프로그램 버전(version) 과 릴리즈(release)

1. 버전을 올리는 것은 크게 메이저 업그레이드와 ㅏ이너 업그레이드가 있다.
2. 10.15.0 버전에서 10은 메이저, 15는 마이너, 0은 메인터넌스(Maintenance) 버그나 유지보수 등 작은 수정을 의미한다.
3. 프로그램을 출시하는 것을 릴리즈 라고 한다. (github releases 탭에서 확인 가능)


#### 원본 저장소와 원격 저장소

1. 기본적으로 원본 저장소에 커밋을 직접 푸시할 수 있는 사람은 원본저장소를 만든 보인(소유자) 뿐이다.
2. 타인이 이 곳으로 푸시하고자 한다면 원본저장소의 소유자가 이 사람을 협력자로 등록해야한다.
3. 등록되지 않은 사람의 푸시 명령은 에러가 난다.
4. 원본저장소의 소유자가 협력자로 등록하려면 해당 프로젝트(원본저장소) 메뉴에서 Settings - Collaborators 탭과 페이지 들어가서
5. Add collaborator 을 통해 계정을 등록하면 된다.
6. 계정을 등록하면 초대 이메일이 나가며, 이를 수락한다면 엑세스 권한이 부여된다.
7. 그러나, 원본저장소의 소유자 입장에서는 협력자가 늘어날수록 원본저잣오를 관리하기가 어렵다.
8. 협력자가 원본저장소에 직접 푸시한다면, 자칫 이력이 훼손될 수 있다.
9. 이럴 때 타 개발자는 원본저장소를 자신의 계정에 fork해서 원격저장소를 생성하고, 이곳에 커밋을 올린 후 원본저장소의 소유자에게 병합요청(풀 리퀘스트)를 보낸다.
10. 원본저장소의 소유자는 개발자의 병합 요청을 검토해서 원본저장소에 병합한다.
11. 다만 fork 한다면, 서로 독립적인 개체가 되기때문에 새 주소를 통한 참조가 필요하다.
12. 적은 수의 개발자가 협업을 한다면, 모두 협력자로 등록하고 브랜치로 나누어서 작업하는 것이 서로의 작업을 한 곳의 프로젝트 이력으로 확인가능하여 효율적이다.
13. 하지만 수많은 개발자가 협력하는 프로젝트라면 fork로 독립 분기를 주는 것이 현명하다.
14. 실제로 페이스북 오프소스 프로젝트 리액트는 컨트리뷰터가 1,200 명이 넘는다.


#### 원본저장소에 풀 리퀘스트 보내기

1. 풀 리퀘스트는 A 브랜치에 B 브랜치를 합치는 것 또 새로 추가된 코드는 다음과 같다는 메시지를 보내는 것이다.
2. 포크한 원격 저장소에서 원본 저장소로 코드를 합치는 과정도 동일하다
3. 정확히 표현하자면, 포크한 원격 저장소의 A 브랜치에서 원본저장소의 B 브랜치로 코드를 합치는 것이다.
4. 풀 리퀘스트를 보내기 전에 정보를 보내주는 화면이 나온다. [head repository]에 내가 포크한 원격 저장소가, [base repository]에 원본저장소가 보여지면 성공읻.

<img src="../GIT Images/git_04.png" align="left" width="80%" height="60%"></img>

5. head의 변경사항을 base에 합치는 것이다.
6. 오픈소스에 풀 리퀘스트를 보내기 전에 '컨드리뷰션 가이드라인 Contribution Guideline' 이 있는 지 확인 하는 것이 좋다.
7. 보통 원본저장소의 README.md 파일에 링크되어 있다.
8. 이 파일에는 컨트리뷰터가 풀 리퀘스트를 보낼 적에 미리 확인하면 좋은 것 등이 기재되어 있다.
9. https://reactjs.org/docs/how-to-contribute.html 을 참고하면 좋다.

#### 원본 저장소에서 풀 리퀘스트를 승인하고, 병합하기

1. Insights의 Forks 탭에서 누가 포크했는 지 알 수 있다.
2. File changed 탭에서는 어떤 새로운 코드가 풀 리퀘스트에 담겨 있는 지 확인이 가능하다.
3. 변경된 코드의 왼쪽 + 버튼을 클릭해 코드 라인별로 댓글을 달 수 있다.
4. Insights 탭의 Contributors 메뉴에서 컨트리 뷰터 여부를 확인 할 수 있고,
5. 프로필 페이제이서 Pin으로 customize 가능하다.


#### git remote add origin 이라는 명령어는 origin 이라는 이름으로 원격저장소의 주소를 저장하라는 것이다. 즉 닉네임 설정이다.


#### 새로운 원격 저장소의 이름은 upstream 이라고 한다. 이는 관용적 닉네임이다.


#### Fetch 패치는 원본저장소의 커밋 히스토리를 받아 오는 것이다. 간단히 말하면 새로고침으로, 패치를 하면 원본저장소 커밋 이력을 업데이트 한다. 이력만 가져오는 거시라서, 내 코드에는 아무런 영향이 없다. 최신 코드를 내 코드에 반영하는 pull 풀 과는 다르다. 따라서 master 브랜치와 origin/master 브랜치가 분기된다.


#### 묵은 커밋을 방금 한 커밋 처럼(이력 조작하기) : 리베이스(Rebase)

1. 풀 리퀘스트를 보냈을 때 충돌이 난다면, 병합하고 싶은 커밋을 내 브랜치의 커밋과 병합해서 병합 커밋을 만들고 이를 풀 리퀘스트로 보내야한다.
2. 그렇게 하면 병합 커밋이 생긴다.
3. 더 깔끔하게 이력을 보내고 싶다면, rebase 이력을 조작하는 방법이 있다.
4. 커밋의 베이스를 똑 떼서 다른 곳으로 붙이는 것이 리베이스 rebase (베이스를 다시 잡다) 이다.
5. 충돌이 있다면 이력을 조작하는 중간에 조용히 고치면 된다.
6. 리베이스는 이력을 조작하는 행위기 때문에, 일반 푸시로는 수행할 수 없다.
7. 히스토리를 강제로 조작하기 때문에, 혼자 사용하는 브랜치에만 해야하고, 특수한 옵션을 붙여서 강제 푸시해야한다.


#### amend (수정) 방금 만든 커밋을 수정하고, 덮어쓰기 (이력 조작 중 하나)

1. amend 는 직전의 커밋을 수정하고 덮어쓰는 개념이다.
2. 기존의 커밋의 완성본(즉 수정본)을 만든 후에 스테이징한다.

<img src="../GIT Images/git_06" align="left" width="80%" height=60%"></img>

3. git commit --ammend 명령어를 사용한다. 라고 했다가 호되게 당했다.
4. git commit --amend 명령어를 사용하면, basic editor 가 나오고 커밋 메시지를 함께 커밋하면 된다.

<img src="../GIT Images/git_07" align="left" width="80%" height=60%"></img>

5. 이미 푸시 넣었던 파일이라면 강제 푸시해야한다!

<img src="../GIT Images/git_08" align="left" width="80%" height=60%"></img>


#### cherry-pick : 커밋 하나만을 떼서 브랜치에 병합 시킨다.

1. 커밋의 모든 부분이 아닌, 해당 커밋의 변경사항만 똑 떼서 브랜치에 반영하고자 할 때 쓰인다.
2. 체리픽 cherry-pick : 선별하다 라는 의미가 있다.
3. 체리(커밋) 만 똑 떼서 붙이는 것.


#### reset : 예전 커밋으로 브랜치를 되돌리기

1. reset : 되돌리기를 의미한다.
2. reset soft 모드와 mixed 모드 가 있다.
3. soft 모드는 스테이징 된 상태로 기존의 커밋들을 놓는 것
4. mixed 모드는 스테이징이 되지 않은 상태로 기존의 커밋들을 놓는 것이다.
5. hard 모드 즉, Hard reset 혹은 reset Hard 모드도 있다.
6. 이 기능은 해당 커밋까지의 브랜치 초기화 즉, 모든 작업 상태를 버리는 것이다.


#### revert : 변경사항 되돌리기

1. reset 은 변경사항을 삭제하는 것인 데, 협업 브랜치에서는 이력 관리가 중요하다.
2. 따라서 삭제에 대한 이력도 남아야 하고, 이를 revert 되돌리기 옵션을 통해서 해결한다.
3. revert 되돌리기를 의미
4. revert 는 방금 한 커밋 만이 아니라, 이전에 한 커밋도 얼마든지 되돌릴 수 있다. 따라서 잘못된 커밋이 있다면,
5. 언제든지 revert 로 되돌린다.


#### stash : 변경사항을 커밋을 만들지 않고 잠시 저장하기

1. 커밋하지 않은 변경사항 파일이 아직 커밋하기에는 애매한 상태라면,
2. 이 변경사항을 잠깐 서랍속에 넣어뒀다가 이따가 다시 꺼내 쓰는 방법을 스태시 stash - 넣어두다 라고 한다.
3. stash 에는 tracked 상태(추적중 - 한번이라도 git에 올렸던 상태)에 파일들만 들어간다.
4. 실무에서 유용하게 쓰인다.


#### CLI

1. Git 를 세세하게 제어할 수 있다.
2. 작업속도면에서 우월하다.
3. CLI 가 보여주는 영어 정보는 세심하게 읽을 것을 권장한다.
4. CLI 명령어 중 [옵션인자] 처럼 대괄호로 둘러싸인 부분은 생략이 가능하다는 뜻이다.
5. CLI 명령어 중 <필수인자> 처럼 부등호로 둘러싸인 부분은 꼭 입력해야 한다는 뜻이다.
6. CLI 명렁어 중 # 표시 이후는 주석으로 명령어에 대한 부연 설명이다.
7. $ 깋와 윗줄에 표시된 경로를 합쳐서 프롬프트 prompt 라고 한다.
8. 프롬프트는 CLI 에서 가장 기본적인 정보를 보여준다.
9. userID @ cpName location 순으로 기본 정보가 표현된다.
10. pwd 확인 처럼 CLI 에서는 꼼꼼한 확인이 중요하다.
11. 리눅스나 맥 OS 에 친숙한 개발자들은 바탕화면 폴더나 다운로드 폴더는 작업 폴더라기보다는 임시 폴더에 가까운 느낌이다. 내 문서 폴더를 주로 작업 폴더로 사용한다.
12. .git 폴더가 있는 폴더 즉 로컬 저장소가 있는 디렉터리는 워킹트리 (working tree) 라고 불린다.


#### git 옵션 설정하기

<b>git 을 사용하기 위해서는 git config 명령을 사용해서 git 옵션 설정을 해야한다.</b>

1. git config --global <option>
2. git config --global <option> <value>
3. git config --global --unset <option>
4. git config --local <option>
5. git config --local <option> <value>
6. git config --local --unset <option>
7. git config --system <option> == 시스템 옵션 (컴퓨터 옵션)
8. git config --system <option> <value>
9. git config --system --unset <option>
10. git config --list

11. git config 명령으로는 옵션을 보거나, 값을 바꿀 수 있다. 
12. 시스템 환경 옵션은 PC 전체를 대상으로,
13. 전역 옵션은 현재 사용자를 대상으로,
14. 지역 옵션은 현재 프로젝트 git 저장소에만 유효하다.
15. 우선순위는 지역 > 전역 > 시스템 순이다.
16. 옵션 값을 이용해서 여러가지 설정이 가능한데 필수적인 옵션은 다음과 같다.

<img src="../GIT Images/git_05.png" align="left" width="80%" height="60%"></img>

<img src="../GIT Images/git_06.png" align="left" width="80%" height="60%"></img>

<img src="../GIT Images/git_07.png" align="left" width="80%" height="60%"></img>


#### 언스테이징 unstaged, unstaging

1. git reset [파일명].. = reset 명령어로 스테이징 된 파일을 언스테이징 할 수 있다.

#### CLI 커밋 생성 및 커밋 메시지, 커밋 로그 적는 규칙

1. git commit 명령어를 실행하면 비주얼 스트디오 코드가 열린다.
2. 첫 줄과 둘째 줄 사이는 반드시 한 줄을 비워야한다.
3. 첫 줄은 작업 내용의 제목, 다음 줄에는 자세하게 작업의 내용을 기록한다.
4. 로그를 볼 때에도 GitHub 의 Pull Request 메뉴 등에서도 이 규칙을 활용해서 내용을 구성하기 때문에 지키는 것이 좋다.

5. 제목과 본문을 빈 줄로 구분한다.
6. 제목의 첫 글자는 대문자로 쓴다.
7. 제목에는 마침표를 넣지 않는다.
8. 동사원형으로 시작한다.
9. 무엇과 왜를 설명한다.


#### CLI 로 log 살펴보기

1. 커밋 히스토리에 보이는 앞의 16진수 7자리 숫자는 커밋 체크섬 혹은 커밋 아이디 이다.

<img src="../GIT Images/git_08.png" align="left" width="80%" height="60%"></img>

2. 1의 정확한 명칭은 SHA1 방식의 해시 체크섬이다.
3. 커밋 체크섬은 영문 소문자와 숫자 조합의 40자리 SHA1 해시 체크섬 값을 가진다. 이 값은 전 우주에서 어떤 커밋을 유일하게 식별 할 수 있는 값이다.
3. 해시는 손도끼라는 뜻으로, 무언가를 잘게 쪼개어 섞어놓는 걸 말하고, 체크섬은 데이터의 정확성을 확인하기 위해서 계산한 어떠한 값을 의미한다.
4. 결국 SHA1 해시 체크섬은 SHA1 이라는 알고리즘을 활용해서 만들어낸 체크섬 값을 말한다.
5. 이 값을 통해서 GIT 은 커밋 객체를 구별하고 오류가 없이 안전하게 저장한다.


#### 도움말 기능 사용하기

1. git help <명령어> 를 수행하면, 웹 브라우저가 열리면서 명령어에 대한 정보가 표시된다. 영어이며, 매우 유용하다.

<img src="../GIT Images/git_09.png" align="left" width="80%" height="60%"></img>

<img src="../GIT Images/git_10.png" align="left" width="80%" height="60%"></img>
